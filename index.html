<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trifecta - Strategic Board Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Game Logic Class
        class TrifectaGame {
        constructor(numPillars = 4, initialLayers = 3) {
            this.rowLayout = [7, 9, 11, 11, 9, 7];
            this.numTiles = this.rowLayout.reduce((a, b) => a + b, 0);
            this.numPillars = numPillars;
            this.initialLayers = initialLayers;
            
            this.tiles = {};
            for (let i = 1; i <= this.numTiles; i++) {
            this.tiles[i] = initialLayers;
            }
            
            this.player1Pos = 1;
            this.player2Pos = this.numTiles;
            this.pillars = new Set();
            this.currentPlayer = 1;
            this.tileOrientations = {};
            this.tileCoords = {};
            
            this.calculateOrientations();
            this.adjacency = this.buildTriangularGrid();
            this.placePillars();
        }
        
        calculateOrientations() {
            let tileNum = 1;
            for (let rowIdx = 0; rowIdx < this.rowLayout.length; rowIdx++) {
            const rowSize = this.rowLayout[rowIdx];
            for (let pos = 0; pos < rowSize; pos++) {
                this.tileOrientations[tileNum] = (pos % 2 === 0);
                tileNum++;
            }
            }
        }
        
        buildTriangularGrid() {
            const adjacency = {};
            const rowStarts = [1];
            
            for (let i = 0; i < this.rowLayout.length - 1; i++) {
            rowStarts.push(rowStarts[rowStarts.length - 1] + this.rowLayout[i]);
            }
            
            for (let rowIdx = 0; rowIdx < this.rowLayout.length; rowIdx++) {
            const rowSize = this.rowLayout[rowIdx];
            const rowStart = rowStarts[rowIdx];
            
            for (let pos = 0; pos < rowSize; pos++) {
                const current = rowStart + pos;
                const neighbors = [];
                const isPointingUp = this.tileOrientations[current];
                
                if (pos > 0) neighbors.push(current - 1);
                if (pos < rowSize - 1) neighbors.push(current + 1);
                
                if (isPointingUp) {
                if (rowIdx < this.rowLayout.length - 1) {
                    const nextRowStart = rowStarts[rowIdx + 1];
                    const nextRowSize = this.rowLayout[rowIdx + 1];
                    const offset = Math.floor((nextRowSize - rowSize) / 2);
                    const targetPos = pos + offset;
                    
                    if (targetPos >= 0 && targetPos < nextRowSize) {
                    neighbors.push(nextRowStart + targetPos);
                    }
                }
                } else {
                if (rowIdx > 0) {
                    const prevRowStart = rowStarts[rowIdx - 1];
                    const prevRowSize = this.rowLayout[rowIdx - 1];
                    const offset = Math.floor((rowSize - prevRowSize) / 2);
                    const targetPos = pos - offset;
                    
                    if (targetPos >= 0 && targetPos < prevRowSize) {
                    neighbors.push(prevRowStart + targetPos);
                    }
                }
                }
                
                adjacency[current] = neighbors;
            }
            }
            
            return adjacency;
        }
        
        placePillars() {
            const available = [];
            for (let i = 3; i < this.numTiles - 1; i++) {
            available.push(i);
            }
            
            const shuffled = available.sort(() => Math.random() - 0.5);
            this.pillars = new Set(shuffled.slice(0, Math.min(this.numPillars, available.length)));
        }
        
        getValidMoves(player) {
            const pos = player === 1 ? this.player1Pos : this.player2Pos;
            const opponentPos = player === 1 ? this.player2Pos : this.player1Pos;
            const neighbors = this.adjacency[pos] || [];
            
            return neighbors.filter(n => this.tiles[n] > 0 && n !== opponentPos);
        }
        
        movePlayer(player, targetTile) {
            const currentPos = player === 1 ? this.player1Pos : this.player2Pos;
            const validMoves = this.getValidMoves(player);
            
            if (!validMoves.includes(targetTile)) {
            return { success: false, message: "Invalid move!" };
            }
            
            let message = "";
            
            if (this.pillars.has(targetTile)) {
            const pushedTo = this.pushPillar(targetTile, currentPos);
            message += "Pillar pushed! ";
            
            if (pushedTo) {
                const opponentPos = player === 1 ? this.player2Pos : this.player1Pos;
                if (pushedTo === opponentPos) {
                message += "Hit opponent! ";
                }
            }
            }
            
            if (player === 1) {
            this.player1Pos = targetTile;
            } else {
            this.player2Pos = targetTile;
            }
            
            return { success: true, message };
        }
        
        pushPillar(pillarTile, fromTile) {
            this.pillars.delete(pillarTile);
            
            const rowStarts = [1];
            for (let i = 0; i < this.rowLayout.length - 1; i++) {
            rowStarts.push(rowStarts[rowStarts.length - 1] + this.rowLayout[i]);
            }
            
            let pillarRow = 0, pillarCol = 0;
            for (let rowIdx = 0; rowIdx < rowStarts.length; rowIdx++) {
            if (pillarTile >= rowStarts[rowIdx] && 
                (rowIdx === rowStarts.length - 1 || pillarTile < rowStarts[rowIdx + 1])) {
                pillarRow = rowIdx;
                pillarCol = pillarTile - rowStarts[rowIdx];
                break;
            }
            }
            
            const isPointingUp = this.tileOrientations[pillarTile];
            let target = null;
            
            if (fromTile === pillarTile - 1) {
            if (isPointingUp && pillarRow + 1 < this.rowLayout.length) {
                const nextRowStart = rowStarts[pillarRow + 1];
                if (pillarCol + 1 < this.rowLayout[pillarRow + 1]) {
                target = nextRowStart + pillarCol + 1;
                }
            } else if (!isPointingUp && pillarRow > 0) {
                const prevRowStart = rowStarts[pillarRow - 1];
                if (pillarCol < this.rowLayout[pillarRow - 1]) {
                target = prevRowStart + pillarCol;
                }
            }
            } else if (fromTile === pillarTile + 1) {
            if (isPointingUp && pillarRow + 1 < this.rowLayout.length) {
                const nextRowStart = rowStarts[pillarRow + 1];
                if (pillarCol < this.rowLayout[pillarRow + 1]) {
                target = nextRowStart + pillarCol;
                }
            } else if (!isPointingUp && pillarRow > 0 && pillarCol > 0) {
                const prevRowStart = rowStarts[pillarRow - 1];
                if (pillarCol - 1 < this.rowLayout[pillarRow - 1]) {
                target = prevRowStart + pillarCol - 1;
                }
            }
            } else {
            if (isPointingUp && pillarRow > 0) {
                const prevRowStart = rowStarts[pillarRow - 1];
                if (pillarCol < this.rowLayout[pillarRow - 1]) {
                target = prevRowStart + pillarCol;
                }
            } else if (!isPointingUp && pillarRow + 1 < this.rowLayout.length) {
                const nextRowStart = rowStarts[pillarRow + 1];
                if (pillarCol < this.rowLayout[pillarRow + 1]) {
                target = nextRowStart + pillarCol;
                }
            }
            }
            
            if (target === null || !this.tiles[target] || this.tiles[target] === 0) {
            return null;
            }
            
            this.tiles[target] -= 1;
            
            if (this.tiles[target] > 0) {
            this.pillars.add(target);
            return target;
            }
            
            return null;
        }
        
        checkGameOver() {
            if (this.tiles[this.player1Pos] === 0) return 2;
            if (this.tiles[this.player2Pos] === 0) return 1;
            
            if (this.currentPlayer === 1 && this.getValidMoves(1).length === 0) return 2;
            if (this.currentPlayer === 2 && this.getValidMoves(2).length === 0) return 1;
            
            return null;
        }
        
        reset() {
            for (let i = 1; i <= this.numTiles; i++) {
            this.tiles[i] = this.initialLayers;
            }
            this.player1Pos = 1;
            this.player2Pos = this.numTiles;
            this.currentPlayer = 1;
            this.pillars = new Set();
            this.placePillars();
        }
        }

        // Main App Component
        function TrifectaApp() {
        const [screen, setScreen] = useState('menu');
        const [game, setGame] = useState(null);
        const [message, setMessage] = useState('');
        const [winner, setWinner] = useState(null);
        const [settings, setSettings] = useState({
            numPillars: 4,
            initialLayers: 3
        });
        
        const startNewGame = () => {
            const newGame = new TrifectaGame(settings.numPillars, settings.initialLayers);
            setGame(newGame);
            setWinner(null);
            setMessage('Click on a highlighted tile to move');
            setScreen('game');
        };
        
        const handleTileClick = (tileNum) => {
            if (!game || winner) return;
            
            const validMoves = game.getValidMoves(game.currentPlayer);
            if (!validMoves.includes(tileNum)) {
            setMessage('Invalid move! Choose a highlighted tile.');
            return;
            }
            
            const result = game.movePlayer(game.currentPlayer, tileNum);
            
            if (result.success) {
            setMessage(result.message || 'Move successful!');
            
            const gameWinner = game.checkGameOver();
            if (gameWinner) {
                setWinner(gameWinner);
                setMessage(`Player ${gameWinner} wins!`);
                return;
            }
            
            game.currentPlayer = 3 - game.currentPlayer;
            // Force re-render by creating new object reference
            setGame(new TrifectaGame(game.numPillars, game.initialLayers));
            // Copy game state
            const newGame = new TrifectaGame(game.numPillars, game.initialLayers);
            newGame.tiles = { ...game.tiles };
            newGame.player1Pos = game.player1Pos;
            newGame.player2Pos = game.player2Pos;
            newGame.currentPlayer = game.currentPlayer;
            newGame.pillars = new Set(game.pillars);
            setGame(newGame);
            }
        };
        
        if (screen === 'menu') {
            return <MainMenu onStart={startNewGame} onSettings={() => setScreen('settings')} 
                            onHelp={() => setScreen('help')} onAbout={() => setScreen('about')} />;
        }
        
        if (screen === 'settings') {
            return <SettingsScreen settings={settings} setSettings={setSettings} onBack={() => setScreen('menu')} />;
        }
        
        if (screen === 'help') {
            return <HelpScreen onBack={() => setScreen('menu')} />;
        }
        
        if (screen === 'about') {
            return <AboutScreen onBack={() => setScreen('menu')} />;
        }
        
        return (
            <GameScreen 
            game={game} 
            message={message} 
            winner={winner}
            onTileClick={handleTileClick}
            onNewGame={startNewGame}
            onMenu={() => setScreen('menu')}
            />
        );
        }

        // Main Menu Component
        function MainMenu({ onStart, onSettings, onHelp, onAbout }) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 flex items-center justify-center p-4">
            <div className="text-center space-y-8 max-w-2xl">
                <div className="space-y-4">
                <h1 className="text-7xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 drop-shadow-lg">
                    TRIFECTA
                </h1>
                <p className="text-xl text-purple-200 italic">Strategic Triangular Warfare</p>
                </div>
                
                <div className="space-y-4">
                <MenuButton icon={<Play />} onClick={onStart}>Start Game</MenuButton>
                <MenuButton icon={<Settings />} onClick={onSettings}>Settings</MenuButton>
                <MenuButton icon={<HelpCircle />} onClick={onHelp}>How to Play</MenuButton>
                <MenuButton icon={<Info />} onClick={onAbout}>About</MenuButton>
                </div>
            </div>
            </div>
        );
        }

        function MenuButton({ icon, onClick, children }) {
        return (
            <button
            onClick={onClick}
            className="w-full max-w-md mx-auto flex items-center justify-center gap-3 bg-purple-600 hover:bg-purple-700 text-white font-bold py-4 px-8 rounded-lg transition-all transform hover:scale-105 shadow-lg"
            >
            {icon}
            <span className="text-xl">{children}</span>
            </button>
        );
        }

        // Settings Screen
        function SettingsScreen({ settings, setSettings, onBack }) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-8">
            <div className="max-w-2xl mx-auto bg-slate-800 rounded-xl p-8 shadow-2xl">
                <h2 className="text-4xl font-bold text-purple-400 mb-6">Settings</h2>
                
                <div className="space-y-6">
                <div>
                    <label className="block text-white text-lg mb-2">Number of Pillars: {settings.numPillars}</label>
                    <input
                    type="range"
                    min="2"
                    max="8"
                    value={settings.numPillars}
                    onChange={(e) => setSettings({ ...settings, numPillars: parseInt(e.target.value) })}
                    className="w-full"
                    />
                </div>
                
                <div>
                    <label className="block text-white text-lg mb-2">Initial Tile Layers: {settings.initialLayers}</label>
                    <input
                    type="range"
                    min="1"
                    max="5"
                    value={settings.initialLayers}
                    onChange={(e) => setSettings({ ...settings, initialLayers: parseInt(e.target.value) })}
                    className="w-full"
                    />
                </div>
                </div>
                
                <button onClick={onBack} className="mt-8 flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg">
                <Home size={20} />
                Back to Menu
                </button>
            </div>
            </div>
        );
        }

        // Help Screen
        function HelpScreen({ onBack }) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-8 overflow-y-auto">
            <div className="max-w-3xl mx-auto bg-slate-800 rounded-xl p-8 shadow-2xl">
                <h2 className="text-4xl font-bold text-purple-400 mb-6">How to Play Trifecta</h2>
                
                <div className="space-y-6 text-white">
                <section>
                    <h3 className="text-2xl font-bold text-purple-300 mb-3">Objective</h3>
                    <p className="text-lg">Outmaneuver your opponent on a triangular grid. Win by destroying the tile your opponent stands on or trapping them with no valid moves.</p>
                </section>
                
                <section>
                    <h3 className="text-2xl font-bold text-purple-300 mb-3">Game Board</h3>
                    <ul className="list-disc list-inside space-y-2 text-lg">
                    <li>54 triangular tiles arranged in rows: 7, 9, 11, 11, 9, 7</li>
                    <li>Triangles alternate between pointing up (‚ñ≥) and down (‚ñΩ)</li>
                    <li>Each tile has multiple layers of health</li>
                    <li>Player 1 (üî¥) starts at tile 1, Player 2 (üîµ) starts at tile 54</li>
                    </ul>
                </section>
                
                <section>
                    <h3 className="text-2xl font-bold text-purple-300 mb-3">Movement</h3>
                    <ul className="list-disc list-inside space-y-2 text-lg">
                    <li>Players alternate turns</li>
                    <li>Move to any adjacent tile (sharing a full edge)</li>
                    <li>Cannot move to destroyed tiles or opponent's tile</li>
                    <li>Valid moves are highlighted in green</li>
                    </ul>
                </section>
                
                <section>
                    <h3 className="text-2xl font-bold text-purple-300 mb-3">Pillars (üèõÔ∏è)</h3>
                    <ul className="list-disc list-inside space-y-2 text-lg">
                    <li>Moving onto a pillar pushes it through the triangle's point</li>
                    <li>The pillar exits opposite from where you entered</li>
                    <li>Pushed pillars damage the tile they land on (reduce 1 layer)</li>
                    <li>Hitting opponent with a pillar is strategic!</li>
                    <li>Pillars on tiles with 1 layer destroy that tile</li>
                    </ul>
                </section>
                
                <section>
                    <h3 className="text-2xl font-bold text-purple-300 mb-3">Winning</h3>
                    <ul className="list-disc list-inside space-y-2 text-lg">
                    <li>Destroy the tile your opponent is standing on</li>
                    <li>Trap your opponent with no valid moves</li>
                    </ul>
                </section>
                
                <section>
                    <h3 className="text-2xl font-bold text-purple-300 mb-3">Legend</h3>
                    <div className="bg-slate-700 p-4 rounded-lg">
                    <p>üî¥ Player 1 | üîµ Player 2 | üèõÔ∏è Pillar</p>
                    <p>‚ñ≥ Triangle pointing up | ‚ñΩ Triangle pointing down</p>
                    <p>Numbers on tiles = remaining layers</p>
                    <p>Green = valid moves | Gold = full health | Orange = damaged | Dark = destroyed</p>
                    </div>
                </section>
                </div>
                
                <button onClick={onBack} className="mt-8 flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg">
                <Home size={20} />
                Back to Menu
                </button>
            </div>
            </div>
        );
        }

        // About Screen
        function AboutScreen({ onBack }) {
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-8">
            <div className="max-w-2xl mx-auto bg-slate-800 rounded-xl p-8 shadow-2xl">
                <h2 className="text-4xl font-bold text-purple-400 mb-6">About Trifecta</h2>
                
                <div className="space-y-4 text-white text-lg">
                <p>
                    <strong className="text-purple-300">Trifecta</strong> is a turn-based strategic board game played on a unique triangular grid.
                </p>
                
                <p>
                    Combining elements of positional strategy, resource management, and tactical warfare, players must carefully plan their moves to outmaneuver their opponent while managing the destructible terrain.
                </p>
                
                <p className="text-purple-200 italic">
                    "In a world of triangles, only the sharpest minds survive."
                </p>
                
                <div className="bg-slate-700 p-4 rounded-lg mt-6">
                    <p className="font-bold text-purple-300 mb-2">Game Design:</p>
                    <p>Created as a strategic board game project</p>
                    <p className="mt-2">Version: 1.0</p>
                </div>
                </div>
                
                <button onClick={onBack} className="mt-8 flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg">
                <Home size={20} />
                Back to Menu
                </button>
            </div>
            </div>
        );
        }

        // Game Screen
        function GameScreen({ game, message, winner, onTileClick, onNewGame, onMenu }) {
        const canvasRef = useRef(null);
        const TILE_SIZE = 50;
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        
        useEffect(() => {
            if (!game || !canvasRef.current) return;
            
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            
            // Calculate tile positions
            const tileCoords = {};
            let tileNum = 1;
            const startY = 80;
            const triangleHeight = TILE_SIZE * 0.866;
            
            const rowStarts = [1];
            for (let i = 0; i < game.rowLayout.length - 1; i++) {
            rowStarts.push(rowStarts[rowStarts.length - 1] + game.rowLayout[i]);
            }
            
            for (let rowIdx = 0; rowIdx < game.rowLayout.length; rowIdx++) {
            const rowSize = game.rowLayout[rowIdx];
            const rowWidth = rowSize * (TILE_SIZE / 2);
            const startX = (CANVAS_WIDTH - rowWidth) / 2;
            const y = startY + rowIdx * triangleHeight;
            
            for (let pos = 0; pos < rowSize; pos++) {
                const x = startX + pos * (TILE_SIZE / 2);
                tileCoords[tileNum] = { x, y };
                tileNum++;
            }
            }
            
            game.tileCoords = tileCoords;
            
            // Draw board
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            const validMoves = game.getValidMoves(game.currentPlayer);
            const TILE_COLORS = {
            3: '#D4AF37',
            2: '#FFD700',
            1: '#FFA500',
            0: '#333333'
            };
            
            for (let tile = 1; tile <= game.numTiles; tile++) {
            const { x, y } = tileCoords[tile];
            const layers = game.tiles[tile];
            const isPointingUp = game.tileOrientations[tile];
            
            let color;
            if (layers === 0) {
                color = TILE_COLORS[0];
            } else if (validMoves.includes(tile)) {
                color = '#00FF00';
            } else {
                color = TILE_COLORS[layers];
            }
            
            const halfBase = TILE_SIZE / 2;
            const height = TILE_SIZE * 0.866;
            
            ctx.beginPath();
            if (isPointingUp) {
                ctx.moveTo(x, y - height * 0.5);
                ctx.lineTo(x - halfBase, y + height * 0.5);
                ctx.lineTo(x + halfBase, y + height * 0.5);
            } else {
                ctx.moveTo(x - halfBase, y - height * 0.5);
                ctx.lineTo(x + halfBase, y - height * 0.5);
                ctx.lineTo(x, y + height * 0.5);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = 'black';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(tile.toString(), x, y - 10);
            
            if (layers > 0) {
                ctx.font = 'bold 14px Arial';
                ctx.fillText(layers.toString(), x, y + 12);
            } else {
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = 'white';
                ctx.fillText('X', x, y + 12);
            }
            
            if (game.pillars.has(tile)) {
                ctx.font = '16px Arial';
                ctx.fillText('üèõÔ∏è', x, y - 20);
            }
            
            if (tile === game.player1Pos) {
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF4444';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('P1', x, y + 4);
            }
            
            if (tile === game.player2Pos) {
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, 2 * Math.PI);
                ctx.fillStyle = '#4444FF';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = 'white';
                ctx.font = 'bold 10px Arial';
                ctx.fillText('P2', x, y + 4);
            }
            }
        }, [game]);
        
        const handleCanvasClick = (e) => {
            if (!game || !game.tileCoords) return;
            
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            let closestTile = null;
            let minDistance = Infinity;
            
            for (let tile = 1; tile <= game.numTiles; tile++) {
            const { x, y } = game.tileCoords[tile];
            const distance = Math.sqrt((clickX - x) ** 2 + (clickY - y) ** 2);
            
            if (distance < TILE_SIZE / 2 && distance < minDistance) {
                closestTile = tile;
                minDistance = distance;
            }
            }
            
            if (closestTile) {
            onTileClick(closestTile);
            }
        };
        
        return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4">
            <div className="max-w-5xl mx-auto">
                <div className="bg-slate-800 rounded-lg p-6 mb-4 shadow-xl">
                <div className="flex justify-between items-center mb-4">
                    <button onClick={onMenu} className="flex items-center gap-2 bg-slate-700 hover:bg-slate-600 text-white font-bold py-2 px-4 rounded-lg">
                    <Home size={18} />
                    Menu
                    </button>
                    
                    <h2 className={`text-3xl font-bold ${game.currentPlayer === 1 ? 'text-red-400' : 'text-blue-400'}`}>
                    {winner ? `Player ${winner} Wins!` : `Player ${game.currentPlayer}'s Turn`}
                    </h2>
                    
                    <button onClick={onNewGame} className="flex items-center gap-2 bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg">
                    <RotateCcw size={18} />
                    New Game
                    </button>
                </div>
                
                <p className="text-center text-white text-lg">{message}</p>
                </div>
                
                <div className="bg-slate-800 rounded-lg p-4 shadow-xl">
                <canvas
                    ref={canvasRef}
                    width={CANVAS_WIDTH}
                    height={CANVAS_HEIGHT}
                    onClick={handleCanvasClick}
                    className="mx-auto cursor-pointer border-2 border-purple-500 rounded-lg"
                    style={{ backgroundColor: '#1A252F' }}
                />
                </div>
                
                <div className="bg-slate-800 rounded-lg p-4 mt-4 shadow-xl">
                <p className="text-center text-white">
                    üî¥ Player 1 | üîµ Player 2 | üèõÔ∏è Pillar | ‚ñ≥ Up | ‚ñΩ Down | Numbers = Layers
                </p>
                </div>
            </div>
            </div>
        );
        }
        
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TrifectaApp />);
    </script>
</body>
</html>